name: Build and Test WaitTime Service

on:
  push:
    branches: [main, develop]
  pull_request:
    branches: [main]

jobs:
  test:
    name: Run Tests
    runs-on: ubuntu-latest
    # Removemos timeout para debug, mas depois podemos reduzir
    # timeout-minutes: 10
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python 3.11
        uses: actions/setup-python@v4
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install httpx-sse
      
      - name: Create test runner script
        run: |
          cat > test_runner.py << 'EOF'
          """
          Test runner que garante que todos os processos sÃ£o encerrados corretamente.
          """
          import asyncio
          import sys
          import os
          import signal
          
          # Configurar environment
          os.environ.update({
              'TEST_DATABASE_URL': 'sqlite+aiosqlite:///:memory:',
              'MAP_SERVICE_URL': 'http://test-map-service.mock',
              'SECRET_KEY': 'test-secret-key-for-tests',
              'LOG_LEVEL': 'WARNING',
              'PYTHONUNBUFFERED': '1'
          })
          
          async def run_tests():
              """Executa os testes de forma assÃ­ncrona."""
              import pytest
              
              args = [
                  'tests/',
                  '--cov=./',
                  '--cov-report=term',
                  '--cov-report=xml:coverage.xml',
                  '--cov-report=html:htmlcov',
                  '-v',
                  '--disable-warnings',
                  '--tb=short',
                  '--capture=no'  # Importante: captura direta
              ]
              
              exit_code = pytest.main(args)
              return exit_code
          
          def main():
              """FunÃ§Ã£o principal."""
              print("ðŸš€ Starting test execution...")
              
              try:
                  # Configurar handler para SIGTERM
                  def signal_handler(signum, frame):
                      print(f"âš ï¸ Received signal {signum}, cleaning up...")
                      sys.exit(0)
                  
                  signal.signal(signal.SIGTERM, signal_handler)
                  signal.signal(signal.SIGINT, signal_handler)
                  
                  # Executar testes
                  loop = asyncio.new_event_loop()
                  asyncio.set_event_loop(loop)
                  
                  try:
                      exit_code = loop.run_until_complete(run_tests())
                  finally:
                      # Fechar loop de forma limpa
                      loop.run_until_complete(loop.shutdown_asyncgens())
                      loop.close()
                  
                  print(f"âœ… Tests completed with exit code: {exit_code}")
                  sys.exit(exit_code)
                  
              except Exception as e:
                  print(f"âŒ Error running tests: {e}")
                  sys.exit(1)
          
          if __name__ == "__main__":
              main()
          EOF
      
      - name: Run tests with isolated process
        id: run-tests
        run: |
          echo "ðŸ”§ Running tests in isolated process..."
          
          # Executar o script Python em um processo separado
          python test_runner.py
          
          # Capturar o cÃ³digo de saÃ­da
          TEST_EXIT_CODE=$?
          echo "Test exit code: $TEST_EXIT_CODE"
          
          # Verificar se os arquivos de cobertura foram gerados
          if [ -f "coverage.xml" ]; then
              echo "âœ… coverage.xml generated"
          else
              echo "âš ï¸ coverage.xml not found"
          fi
          
          if [ -d "htmlcov" ]; then
              echo "âœ… htmlcov directory generated"
          else
              echo "âš ï¸ htmlcov directory not found"
          fi
          
          # Sair com o cÃ³digo de teste
          exit $TEST_EXIT_CODE
      
      - name: Force cleanup of any hanging processes
        if: always()
        run: |
          echo "ðŸ§¹ Cleaning up any remaining processes..."
          
          # Listar processos Python antes de limpar
          echo "Python processes before cleanup:"
          ps aux | grep -E "(python|pytest)" | grep -v grep || true
          
          # Matar processos Python de forma segura
          pkill -f "python.*test" || true
          pkill -f "pytest" || true
          
          # Pequena pausa para garantir que os processos foram encerrados
          sleep 2
          
          echo "Python processes after cleanup:"
          ps aux | grep -E "(python|pytest)" | grep -v grep || true
      
      - name: Upload coverage reports
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: coverage-reports
          path: |
            coverage.xml
            htmlcov/
          retention-days: 7
          if-no-files-found: warn
      
      - name: Final verification
        run: |
          echo "ðŸ“‹ Final verification:"
          echo "- Job: ${{ github.job }}"
          echo "- Workflow: ${{ github.workflow }}"
          echo "- Run ID: ${{ github.run_id }}"
          echo "âœ… Test job should complete now"

  sonarqube:
    name: SonarQube Scan
    runs-on: ubuntu-latest
    needs: [test]
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
      
      - name: Download coverage report
        uses: actions/download-artifact@v4
        with:
          name: coverage-reports
      
      - name: SonarQube Scan
        uses: SonarSource/sonarqube-scan-action@v7.0.0
        env:
          SONAR_TOKEN: ${{ secrets.SONAR_TOKEN }}
          SONAR_HOST_URL: ${{ secrets.SONAR_HOST_URL }}
        with:
          args: >
            -Dsonar.sources=.
            -Dsonar.exclusions=tests/**,example_client.py,mqtt_configs.py,mosquitto.conf,docker-compose.yml,mosquitto.log,*.md
            -Dsonar.tests=tests
            -Dsonar.test.inclusions=tests/**/*.py
            -Dsonar.python.coverage.reportPaths=coverage.xml
            -Dsonar.scm.provider=git
            -Dsonar.sourceEncoding=UTF-8
            -Dsonar.python.version=3.11

  # Job opcional para garantir que tudo estÃ¡ funcionando
  verify:
    name: Verify Pipeline
    runs-on: ubuntu-latest
    needs: [test, sonarqube]
    if: always()
    
    steps:
      - name: Pipeline status
        run: |
          echo "ðŸ“Š Pipeline Status Summary:"
          echo "- Test job: ${{ needs.test.result }}"
          echo "- SonarQube job: ${{ needs.sonarqube.result }}"
          echo ""
          echo "ðŸŽ‰ Pipeline completed!"